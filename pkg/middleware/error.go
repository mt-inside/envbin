package middleware

import (
	"fmt"
	"math/rand"
	"net"
	"net/http"

	"github.com/go-logr/logr"
	"github.com/spf13/viper"
)

func Error(w http.ResponseWriter, r *http.Request) {
	log := r.Context().Value(CtxKeyLog).(logr.Logger)

	if viper.GetFloat64("ErrorRate") > rand.Float64() {
		switch viper.GetString("ErrorType") {
		case "http":
			log.V(1).Info("Injecting http 500 error")

			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "injected error: http")
		case "tcp-fin":
			log.V(1).Info("Closing TCP stream with FIN")

			conn := r.Context().Value(CtxKeyConn).(net.Conn)
			conn.Close()

			//case "tcp-rst": - dealt with in the server's connection state change event handler

			/* See this thread and Glynn's replies: https://www.spinics.net/lists/linux-c-programming/msg01342.html
			* RST can't be forced from user-space; there's no syscall for it.
			* It's sent by the kernel when a connection is closed and data-loss results.
			* FIN just says "we're done here, I won't be sending anything else, and I don't expect anything else from you
			* - can use shutdown() to close one half of a full-duplex connection
			* RST says "there is no connection", eg
			* - "I'm not expecting anything; no socket is bound to that port"
			* - "I'm not exepcting that sequence number"
			* - "This port is firewalled from you", etc
			* RST also says "this connection has to go, and you should know there's data loss, eg there's still stuff I was meant to send you (maybe I sent it and you haven't ACK'd it yet), or I know there's stuff from you in my buffers, but it's not been read, maybe the process doing that crashed"
			*
			* Note that FIN and RST is part of the tcp protocol, and is generated by the kernel.
			* - close() and shutdown() are the sockets API, which isn't the same thing.
			* Forcing a RST from go is particularly hard. I tried
			* - Pumping 100k into the write buffer, disabling the flushing done in the Rate middleware, then os.Exit()ing immediately - go (presumably the runtime) seems to deliver the content then do an orderly shutdown with FIN
			* - There basically seems to be no way to exit the process "brually" enough.
			* - os.Exit(), panic(), syscall.Exit() don't do it
			* - You can't even crash go with a nil-ptr deref.
			* What worked in the end was Closing the underlying connection for an HTTP request before the request had been read, hence a RST due to data loss
			 */
		}
	}
}
